library(gsDesign)
?gsDesign
?gsSurv
library(rpact)
?getDesignGroupSequential
getSampleSizeSurvival()
?getSampleSizeSurvival()
?getSimulationMeans
?getSimulationSurvival
?p23::simu.p23trial
0.1/0.9
0.11*0.7
rep(c(1,0), each = c(3,4))
rep(c(1,0); each = c(3hazardC = c(0.1, 0.11);hazardT = c(0.07, 0.088);accrual_rate = c(20, 20);
3hazardC = c(0.1, 0.11);hazardT = c(0.07, 0.088);accrual_rate = c(20, 20);
hazardC = c(0.1, 0.11);hazardT = c(0.07, 0.088);accrual_rate = c(20, 20);
n = c(400, 400); allocationT = 0.5;dropoutC = c(0, 0); dropoutT = c(0, 0),4)
hazardC = c(0.1, 0.11);hazardT = c(0.07, 0.088);accrual_rate = c(20, 20);
n = c(400, 400); allocationT = 0.5;dropoutC = c(0, 0); dropoutT = c(0, 0)
## Simulate survival times
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
n = c(20, 20)
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
subgroup
nT = round(n*allocationT)
nC = n - nT
nT
nC
n = c(40, 20)
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
nT = round(n*allocationT)
nC = n - nT
nT
nC
trt <- c(rep(1,nT[1]), rep(0, nC[1]), rep(1, nT[2]), rep(0, nT[2]))
trt
subgroup
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
nT = round(n*allocationT)
nC = n - nT
trt <- c(rep(1,nT[1]), rep(0, nC[1]), rep(1, nT[2]), rep(0, nT[2]))
ntotal <- sum(n)
hrates <- c(rep(hazardT[1],nT[1]), rep(hazardC[1], nC[1]),
rep(hazardT[2], nT[2]), rep(hazardC[2], nT[2]))
hrates
trt
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
nT = round(n*allocationT)
nC = n - nT
trt <- c(rep(1,nT[1]), rep(0, nC[1]), rep(1, nT[2]), rep(0, nT[2]))
ntotal <- sum(n)
hazard_rates <- c(rep(hazardT[1],nT[1]), rep(hazardC[1], nC[1]),
rep(hazardT[2], nT[2]), rep(hazardC[2], nT[2]))
surv_time <- rexp(ntotal, rate = hazard_rates)
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
nT = round(n*allocationT)
nC = n - nT
trt <- c(rep(1,nT[1]), rep(0, nC[1]), rep(1, nT[2]), rep(0, nT[2]))
ntotal <- sum(n)
hazard_rates <- c(rep(hazardT[1],nT[1]), rep(hazardC[1], nC[1]),
rep(hazardT[2], nT[2]), rep(hazardC[2], nT[2]))
surv_time <- rexp(ntotal, rate = hazard_rates)
drop_rates <- c(rep(dropoutT[1],nT[1]), rep(dropoutC[1], nC[1]),
rep(dropoutT[2], nT[2]), rep(dropoutC[2], nT[2]))
drop_rates[drop_rates<=0] <- 1e-10
cen_time <- rexp(ntotal, rate = drop_rates)
?ratio
ratio=1
r <- ratio/(ratio+1)
subgroup <- c(rep(1, n[1]), rep(0, n[2]))
nT = round(n*r)
nC = n - nT
trt <- c(rep(1,nT[1]), rep(0, nC[1]), rep(1, nT[2]), rep(0, nT[2]))
ntotal <- sum(n)
hazard_rates <- c(rep(hazardT[1],nT[1]), rep(hazardC[1], nC[1]),
rep(hazardT[2], nT[2]), rep(hazardC[2], nT[2]))
surv_time <- rexp(ntotal, rate = hazard_rates)
drop_rates <- c(rep(dropoutT[1],nT[1]), rep(dropoutC[1], nC[1]),
rep(dropoutT[2], nT[2]), rep(dropoutC[2], nT[2]))
drop_rates[drop_rates<=0] <- 1e-10
cen_time <- rexp(ntotal, rate = drop_rates)
nT
nC
f.nEachMonth <- function (N=600, A=24, w=2, r=2, Lambda=NULL) {
N1 = ceiling(N * (r/(r+1)))
N0 = ceiling(N - N1)
#When r > 1, the control arm has smaller number of pts.
#Just need to determine enrollment for control arm per month,
#then to obtain enrollment for experimental arm by n1i = n0i * r.
n1 = n0 = rep(NA, A) #enrollment by month
randdt1 = rep(NA, N1) #randomization date
randdt0 = rep(NA, N0)
#Determine number of pts per month for control arm
#(i-1)th month cumulative enrolled pts
cLastN0 = 0; s0 = 0; i = 1
while((s0 < N0 || s1 < N1) && i <= A){
#ith month: cumulative #pts
if (is.null(Lambda)){
cN0i = max(ceiling((i/A)^w * N0), 1)
} else {
cN0i = max(ceiling(Lambda(i) * N0), 1)
}
n0[i] = max(cN0i - cLastN0, 1)
#if (i == A) {n0[i] = N0 - sum(n0[1:(A-1)]) }
cLastN0 = cN0i
s0 = s0 + n0[i]
s1 = s0 * r
i = i + 1
}
n1 = n0 * r
#Extra patients
ex1 = ceiling((N - sum(n0) - sum(n1))*r/(r+1))
ex0 = ceiling((N - sum(n0) - sum(n1))*1/(r+1))
n0[A] = n0[A] + ex0
n1[A] = n1[A] + ex1
#L = max(length(n0[!is.na(n0)]), length(n1[!is.na(n1)]))
#Patch for extreme rare scenarios that 0 enrollment in the last month
#  if(n0[A] == 0 && n0[A-1] > 1){n0[A-1] = n0[A-1]-1; n0[A]=1}
#  if(n1[A] == 0 && n1[A-1] > 1){n1[A-1] = n1[A-1]-1; n1[A]=1}
o = list()
o$n0 = n0[n0>0 & !is.na(n0)]
o$n1 = n1[n1>0 & !is.na(n0)]
return(o)
}
f.nEachMonth(N=40, A=2, w=1, r=1, Lambda=NULL)
Lambda = function(t){(t/12)*as.numeric(t<= 12) + as.numeric(t > 12)}
Lambda
plot(Lambda)
enroll_time <- rep(NA, ntotal)
S.indx <- which(subgroup==1)
S.size <- length(S.indx)
S.size
S.size/accrual_rate[1]
Lambda = function(t){(t/A)*as.numeric(t<= A) + as.numeric(t > A)}
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=ratio, Lambda=Lambda)$n0
A = S.size/accrual_rate[1]
Lambda = function(t){(t/A)*as.numeric(t<= A) + as.numeric(t > A)}
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=ratio, Lambda=Lambda)$n0
nEachMonth
A = 12
Lambda = function(t){(t/A)*as.numeric(t<= A) + as.numeric(t > A)}
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=ratio, Lambda=Lambda)$n0
nEachMonth
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=ratio, Lambda=Lambda)
nEachMonth
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=2, Lambda=Lambda)
nEachMonth
A = 3.5
Lambda = function(t){(t/A)*as.numeric(t<= A) + as.numeric(t > A)}
nEachMonth = f.nEachMonth(N=S.size, A=A, w=NULL, r=ratio, Lambda=Lambda)
nEachMonth
sum(accrual_rate)
ntotal/sum(accrual_rate)
n
40/20
accrual_rate <- c(20,10)
ntotal/sum(accrual_rate)
enroll_time <- rep(NA, ntotal)
F.enroll <- rpwexp_enroll(
n = ntotal, enroll_rate = data.frame(
duration = c(ntotal/sum(accrual_rate)),
rate = sum(accrual_rate)))
library(simtrial)
library(simtrial)
sim_pw_surv()
sim_pw_surv
unlist(mapply(rep,3,20))
?sim_pw_surv
library(enrichDesign)
library(rpact)
?getPowerSurvival
?getDesignGroupSequential
?getEventProbabilities
n = 800; prop_S = 0.5; duration = 20; targetEvents.S = c(112, 280);
CP.Sc.threshold = 0.3; CP.S.threshold = 0.8; CP.F.threshold = 0.8;
hazard_S = c(0.1, 0.1*0.7); hazard_Sc = c(0.12, 0.12*0.81);
dropout_S = c(0, 0); dropout_Sc = c(0, 0); ratio = 1; alpha = 0.025
nF <- n
nS <- n*prop_S
nSc <- nF - nS
hrS <- hazard_S[2]/hazard_S[1]
hrSc <- hazard_Sc[2]/hazard_Sc[1]
hrF <- exp(prop_S*log(hrS)+(1-prop_S)*log(hrSc))
medS_con <- log(2)/hazard_S[1]
medSc_con <- log(2)/hazard_Sc[1]
medF_con <- medS_con*prop_S+medSc_con*(1-prop_S)
dropoutTime <- 12
dropoutRate1S = 1-exp(-dropout_S[2]*dropoutTime)
dropoutRate2S = 1-exp(-dropout_S[1]*dropoutTime)
dropoutRate1Sc = 1-exp(-dropout_Sc[2]*dropoutTime)
dropoutRate2Sc = 1-exp(-dropout_Sc[1]*dropoutTime)
dropoutRate1F = dropoutRate1S*prop_S + dropoutRate1Sc*(1-prop_S)
dropoutRate2F = dropoutRate2S*prop_S + dropoutRate2Sc*(1-prop_S)
targetEvents_S <- targetEvents.S
## GSD design as a reference
d <- getDesignGroupSequential(kMax = 2,
alpha = alpha,
sided = 1,
informationRates = targetEvents_S/targetEvents_S[2],
typeOfDesign = "noEarlyEfficacy")
dS <- getPowerSurvival(design = d, maxNumberOfEvents = targetEvents_S[2],
lambda1 = hazard_S[2],
lambda2 = hazard_S[1],
allocationRatioPlanned = ratio,
accrualTime = c(0, duration),
accrualIntensity = nS/duration,
directionUpper = FALSE,
dropoutRate1 = dropoutRate1S,
dropoutRate2 = dropoutRate2S,
dropoutTime = dropoutTime)
dSpower <- dS$overallReject
times <- dS$analysisTime
times
# expected number of events for S^c
probEvent <- getEventProbabilities(time = times, maxNumberOfSubjects = nSc,
lambda1 = hazard_Sc[2],
lambda2 = hazard_Sc[1],
allocationRatioPlanned = ratio,
accrualTime = c(0, duration),
accrualIntensity = nSc/duration,
dropoutRate1 = dropoutRate1Sc,
dropoutRate2 = dropoutRate2Sc,
dropoutTime = dropoutTime)
targetEvents_Sc <- ceiling(probEvent$overallEventProbabilities*nSc)
targetEvents_Sc
hrF
hazard_Sc[2]
dropoutRate1Sc
nSc
hrS
hrSc
(targetEvents_Sc+targetEvents_S)
n = 800; prop_S = 0.5; duration = 20; targetEvents.S = c(112, 280);
CP.Sc.threshold = 0.3; CP.S.threshold = 0.8; CP.F.threshold = 0.8;
hazard_S = c(log(2)/10, log(2)/10*0.7); hazard_Sc = c(log(2)/11, log(2)/11*0.81);
dropout_S = c(0, 0); dropout_Sc = c(0, 0); ratio = 1; alpha = 0.025
# prepare variables
nF <- n
nS <- n*prop_S
nSc <- nF - nS
hrS <- hazard_S[2]/hazard_S[1]
hrSc <- hazard_Sc[2]/hazard_Sc[1]
hrF <- exp(prop_S*log(hrS)+(1-prop_S)*log(hrSc))
medS_con <- log(2)/hazard_S[1]
medSc_con <- log(2)/hazard_Sc[1]
medF_con <- medS_con*prop_S+medSc_con*(1-prop_S)
dropoutTime <- 12
dropoutRate1S = 1-exp(-dropout_S[2]*dropoutTime)
dropoutRate2S = 1-exp(-dropout_S[1]*dropoutTime)
dropoutRate1Sc = 1-exp(-dropout_Sc[2]*dropoutTime)
dropoutRate2Sc = 1-exp(-dropout_Sc[1]*dropoutTime)
dropoutRate1F = dropoutRate1S*prop_S + dropoutRate1Sc*(1-prop_S)
dropoutRate2F = dropoutRate2S*prop_S + dropoutRate2Sc*(1-prop_S)
targetEvents_S <- targetEvents.S
## GSD design as a reference
d <- getDesignGroupSequential(kMax = 2,
alpha = alpha,
sided = 1,
informationRates = targetEvents_S/targetEvents_S[2],
typeOfDesign = "noEarlyEfficacy")
# power for S
dS <- getPowerSurvival(design = d, maxNumberOfEvents = targetEvents_S[2],
lambda1 = hazard_S[2],
lambda2 = hazard_S[1],
allocationRatioPlanned = ratio,
accrualTime = c(0, duration),
accrualIntensity = nS/duration,
directionUpper = FALSE,
dropoutRate1 = dropoutRate1S,
dropoutRate2 = dropoutRate2S,
dropoutTime = dropoutTime)
dSpower <- dS$overallReject
times <- dS$analysisTime
# expected number of events for S^c
probEvent <- getEventProbabilities(time = times, maxNumberOfSubjects = nSc,
lambda1 = hazard_Sc[2],
lambda2 = hazard_Sc[1],
allocationRatioPlanned = ratio,
accrualTime = c(0, duration),
accrualIntensity = nSc/duration,
dropoutRate1 = dropoutRate1Sc,
dropoutRate2 = dropoutRate2Sc,
dropoutTime = dropoutTime)
targetEvents_Sc <- ceiling(probEvent$overallEventProbabilities*nSc)
targetEvents_Sc
# expected number of events for F
targetEvents_F <- (targetEvents_Sc+targetEvents_S)
targetEvents_F
dF <- getPowerSurvival(design = d, hazardRatio = hrF,
maxNumberOfEvents = targetEvents_F[2],
lambda2 = log(2) / medF_con,
allocationRatioPlanned = ratio,
accrualTime = c(0, duration),
accrualIntensity = nF/duration,
dropoutRate1 = dropoutRate1F,
dropoutRate2 = dropoutRate2F,
dropoutTime = dropoutTime,
directionUpper = FALSE)
dFpower <- dF$overallReject
dF$overallReject
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_Sc # number of events at IA and FA
delta <- -log(hrSc) # assumed delta: negative log hazard ratio
hr.est <- HRs[1]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dF$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CPs[i] <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
HR.Sc.threshold <- HRs[CPs<=CP.Sc.threshold]
HR.Sc.threshold
CP.Sc.threshold
CPs
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_Sc # number of events at IA and FA
delta <- -log(hrSc) # assumed delta: negative log hazard ratio
hr.est <- HRs[i]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dF$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CPs[i] <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
HR.Sc.threshold <- HRs[CPs<=CP.Sc.threshold]
HR.Sc.threshold
HR.Sc.threshold <- min(HRs[CPs<=CP.Sc.threshold])
HR.Sc.threshold
CP.S.threshold
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_S # number of events at IA and FA
delta <- -log(hrS) # assumed delta: negative log hazard ratio
hr.est <- HRs[i]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dS$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CP <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
HRs[CPs>=CP.S.threshold]
CP.S.threshold
CPs
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_S # number of events at IA and FA
delta <- -log(hrS) # assumed delta: negative log hazard ratio
hr.est <- HRs[i]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dS$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CP[i] <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
HR.S.threshold <- min(HRs[CPs>=CP.S.threshold])
HRs[CPs>=CP.S.threshold]
CP
CPs>=CP.S.threshold
CP
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_S # number of events at IA and FA
delta <- -log(hrS) # assumed delta: negative log hazard ratio
hr.est <- HRs[i]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dS$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CPs[i] <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
CPs
HRs[CPs>=CP.S.threshold]
max(HRs[CPs>=CP.S.threshold])
HRs <- seq(0.5, 1.5, 0.01)
CPs <- rep(NA, length(HRs))
for(i in 1:length(HRs)){
D <- targetEvents_F # number of events at IA and FA
delta <- -log(hrF) # assumed delta: negative log hazard ratio
hr.est <- HRs[i]
z <- -log(hr.est)/sqrt(4/D[1])
b <- -log(dF$criticalValuesEffectScale[2])/sqrt(4/D[2]) # boundary at FA for S
CPs[i] <- 1-pnorm( b*sqrt(D[2]/(D[2]-D[1])) - z*sqrt(D[1]/(D[2]-D[1])) - delta/sqrt(4/(D[2]-D[1])) )
}
HR.F.threshold <- max(HRs[CPs>=CP.F.threshold])
HR.F.threshold
library(enrichDesign)
rm(list=ls())
getDesignParameters(n)
getDesignParameters()
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
d <- simu_enrich_trial(n = 200, prop_S = 0.5, duration = 10)
object <- getZstats(d, targetEvents.S = c(28, 70))
getZtests_AED(object)
d <- simu_enrich_trial(n = 200, prop_S = 0.5, duration = 10)
object <- getZstats(d, targetEvents.S = c(28, 70))
getZtests_AED(object)
getOC <- function(seed = 2024, nsim = 1000, n = 800, prop_S = 0.5, duration = 25,
targetEvents.S = c(112, 280), HR.Sc.threshold = 1, HR.S.threshold = 0.8,
HR.F.threshold = 0.8, hazard_S = c(0.1, 0.1), hazard_Sc = c(0.12, 0.12),
dropout_S = c(0, 0), dropout_Sc = c(0, 0), w = 1, ratio = 1, alpha = 0.025){
## Start simulation
set.seed(seed)
AED.simes <- matrix(NA, nrow = nsim, ncol = 5)
colnames(AED.simes) <- c("S.reject", "F.reject", "S.selected", "F.selected", "samplesize")
AED.dunnett <- AED2.dunnett <- AED2.simes <- AED.simes
GSD.ht <- GSD.simes <- GSD.dunnett <- AED.simes
for(sim in 1:nsim){
## Simulate survival times and tumor responses
d <- simu_enrich_trial(n = n, prop_S = prop_S, ratio = ratio, duration = duration,
hazard_S = hazard_S, hazard_Sc = hazard_Sc,
dropout_S = dropout_S, dropout_Sc = dropout_Sc, w = w)
## get Z statistics
Zstats <- getZstats(dat = d, targetEvents.S = targetEvents.S)
## get test results: AED
res <- getZtests_AED(object = Zstats, alpha = alpha, HR.Sc.threshold = HR.Sc.threshold,
HR.S.threshold = HR.S.threshold, HR.F.threshold = HR.F.threshold)
AED.dunnett[sim, ] <- res$reject.dunnett
AED.simes[sim, ] <- res$reject.simes
## get test results: AED and pick the winner
res <- getZtests_AED2(object = Zstats, alpha = alpha, HR.Sc.threshold = HR.Sc.threshold)
AED2.dunnett[sim, ] <- res$reject.dunnett
AED2.simes[sim, ] <- res$reject.simes
## get test results: GSD
res <- getZtests_GSD(object = Zstats, alpha = alpha, HR.Sc.threshold = HR.Sc.threshold)
GSD.ht[sim,] <- res$reject.ht
GSD.dunnett[sim, ] <- res$reject.dunnett
GSD.simes[sim, ] <- res$reject.simes
}
return(list(AED.dunnett = AED.dunnett, AED.simes = AED.simes,
GSD.ht = GSD.ht, GSD.dunnett = GSD.dunnett, GSD.simes = GSD.simes,
AED2.dunnett = AED2.dunnett, AED2.simes = AED2.simes))
}
res <- getOC(seed = 24232, nsim=10)
lapply(res, function(x) mean(apply(x[,1:2], 1, any, na.rm=TRUE)))
res$AED.dunnett
res <- getOC_par(ncore = 2, seed = 24232, nsim=10)
library(enrichDesign)
res <- getOC_par(ncore = 2, seed = 24232, nsim=10)
lapply(res, function(x) mean(apply(x[,1:2], 1, any, na.rm=TRUE)))
res$AED.dunnett
adjust
adjustment
reject
library(enrichDesign)
library(enrichDesign)
d <- simu_enrich_trial(n = 200, prop_S = 0.5, duration = 10)
object <- getZstats(d, targetEvents.S = c(28, 70))
getZtests_GSD(object)
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
log(0.4)<log(0.5)
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
d <- simu_enrich_trial(n = 200, prop_S = 0.5, duration = 10)
library(enrichDesign)
library(enrichDesign)
getZtests_AED2
library(enrichDesign)
library(enrichDesign)
library(enrichDesign)
